/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   matrix_mult.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: frapp <fabi@student.42.fr>                 +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/22 02:11:26 by frapp             #+#    #+#             */
/*   Updated: 2024/05/26 03:09:22 by frapp            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3D.h"
#include "../MLX42/include/MLX42/MLX42.h"

/*
for
	{x1,x2,x3}
	*
	{x11,x12,x13,x14
	x21,x22,x23,x24
	x31,x32,x33,x34
	x41,x42,x43,x44}
*/

void	mat4x4_mult_mat4x4(float a[4][4], float b[4][4], float r[4][4])
{
	r[0][1] = a[0][0] * b[0][1] + a[0][1] * b[1][1] + a[0][2] * b[2][1] + a[0][3] * b[3][1];
	r[0][2] = a[0][0] * b[0][2] + a[0][1] * b[1][2] + a[0][2] * b[2][2] + a[0][3] * b[3][2];
	r[0][3] = a[0][0] * b[0][3] + a[0][1] * b[1][3] + a[0][2] * b[2][3] + a[0][3] * b[3][3];
	r[1][0] = a[1][0] * b[0][0] + a[1][1] * b[1][0] + a[1][2] * b[2][0] + a[1][3] * b[3][0];
	r[1][1] = a[1][0] * b[0][1] + a[1][1] * b[1][1] + a[1][2] * b[2][1] + a[1][3] * b[3][1];
	r[1][2] = a[1][0] * b[0][2] + a[1][1] * b[1][2] + a[1][2] * b[2][2] + a[1][3] * b[3][2];
	r[1][3] = a[1][0] * b[0][3] + a[1][1] * b[1][3] + a[1][2] * b[2][3] + a[1][3] * b[3][3];
	r[2][0] = a[2][0] * b[0][0] + a[2][1] * b[1][0] + a[2][2] * b[2][0] + a[2][3] * b[3][0];
	r[2][1] = a[2][0] * b[0][1] + a[2][1] * b[1][1] + a[2][2] * b[2][1] + a[2][3] * b[3][1];
	r[2][2] = a[2][0] * b[0][2] + a[2][1] * b[1][2] + a[2][2] * b[2][2] + a[2][3] * b[3][2];
	r[2][3] = a[2][0] * b[0][3] + a[2][1] * b[1][3] + a[2][2] * b[2][3] + a[2][3] * b[3][3];
	r[3][0] = a[3][0] * b[0][0] + a[3][1] * b[1][0] + a[3][2] * b[2][0] + a[3][3] * b[3][0];
	r[3][1] = a[3][0] * b[0][1] + a[3][1] * b[1][1] + a[3][2] * b[2][1] + a[3][3] * b[3][1];
	r[3][2] = a[3][0] * b[0][2] + a[3][1] * b[1][2] + a[3][2] * b[2][2] + a[3][3] * b[3][2];
	r[3][3] = a[3][0] * b[0][3] + a[3][1] * b[1][3] + a[3][2] * b[2][3] + a[3][3] * b[3][3];
}

// void	matrix_mult_vec3_4x4(t_vec3 *v, const float m_b[4][4], t_vec3 *re)
// {
// 	re->x = v->x *  m_b[0][0] + v->y * m_b[1][0] + v->z * m_b[2][0] + m_b[3][0];
// 	re->y = v->x *  m_b[0][1] + v->y * m_b[1][1] + v->z * m_b[2][1] + m_b[3][1];
// 	re->z = v->x *  m_b[0][2] + v->y * m_b[1][2] + v->z * m_b[2][2] + m_b[3][2];
// 	re->w = v->x *  m_b[0][3]+ v->y * m_b[1][3] + v->z * m_b[2][3] + m_b[3][3];
// 	if (re->w != 0.0f)
// 	{
// 		re->x /= re->w;
// 		re->y /= re->w;
// 		re->z /= re->w;
// 	}
// }

void	matrix_mult_vec3_4x4(t_vec3 *v, const float m_b[4][4], t_vec3 *re)
{
	re->x = v->x *  m_b[0][0] + v->y * m_b[1][0] + v->z * m_b[2][0] + v->w * m_b[3][0];
	re->y = v->x *  m_b[0][1] + v->y * m_b[1][1] + v->z * m_b[2][1] + v->w * m_b[3][1];
	re->z = v->x *  m_b[0][2] + v->y * m_b[1][2] + v->z * m_b[2][2] + v->w * m_b[3][2];
	re->w = v->x *  m_b[0][3]+ v->y * m_b[1][3] + v->z * m_b[2][3] + v->w * m_b[3][3];
}

void	matrix_mult_1x3_3x3(t_vec3 v, float mb[3][3], float m_result[3])
{
	m_result[0] = v.x * mb[0][0];
	m_result[0] += v.y * mb[1][0];
	m_result[0] += v.z * mb[2][0];
	m_result[1] = v.x * mb[0][1];
	m_result[1] += v.y * mb[1][1];
	m_result[1] += v.z * mb[2][1];
	m_result[2] = v.x * mb[0][2];
	m_result[2] += v.y * mb[1][2];
	m_result[2] += v.z * mb[2][2];
}


